数据结构 1，存储数据的集合 2，存储的数据之间有特殊关系

初阶数据结构 1，数组(Array)
           2，链表(Linked List) 链表三要素(元素 元素地址 指针)
           3,堆栈(Stack)
           4，队列(Queue)
           常用数据结构是线性结构

高阶数据结构 1，树(Tree) 2,集(Set) 3, 映射(Map) 4,图(Graph) 非线性结构

//git init  把一个文件夹变成git本地仓库
//git status
// git add(文件名) 把文件修改添加到暂存区
//git checkout -- Note.txt 撤销缓存区修改  git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。
// git commit（把add的代码提交到分支）把暂存区的所有内容添加到当前分支
//git log 提交日志
//git reset --Hard HEAD^ 回退上一个版本

git init
git add README.md
git commit -m "first commit"
git remote add origin git@github.com:zhengjingfeng/git.git
git push -u origin master

查看分支：git branch

创建分支：git branch <name>

切换分支：git checkout <name>

创建+切换分支：git checkout -b <name>

合并某分支到当前分支：git merge <name>

删除分支：git branch -d <name>

// git clone git branch git -- help(查看命令)
// git checkout(剪出分支)
//fork/clone(add commit push)

//网络请求开始
http 请求3位的返回码中 3开头是重定向，4开头代表客服端错误（404页面：file not found），5开头代表服务器错误，当然200是正常响应
cookie是客服端保持状态的方案 session是在服务端保持状态的方案

域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户

//不同事件监听的优先级
1.onTouch返回true，则onTouchEvent和onClick都不会执行；
2.onTouch(onTouchListener)返回false，如果onTouchEvent不是返回super.onTouchEvent(event);
  也就算是说不管onTouchEvent返回true还是false，onClick(onCLickListener)都不会执行，
  这可以从super的源码看出（源码里会进行判断执行到OnCLickListener）,而且我们知道onClick执行也就会在触摸抬起(up)的时候执行；

//Android的UI操作是线程不安全的
线程安全：
多个线程访问时，采用枷锁的机制，当一个线程访问类的某个数据时，进行保护，其它线程不能访问，当前线程执行完毕后，其它线程才能访问。不会出现数据错乱不一致或数据污染
线程不安全：
不采用枷锁机制，多个线程可以同时访问，可能会造成多个线程都在修改数据造成所得到的数据是脏数据

//单位转换（这次看懂了，不想再看第二遍了）
px:像素 手机的分辨率 如：小米8的分辨率为 2248*1080 1px代表屏幕上的一个像素点。
dip:dots per inch 对角线每英寸对应的像素点。dpi = \dfrac{\sqrt{height^2 + width^2}}{size}。
    height和width即为长宽的像素，平方和即为对角线的像素个数，size即我们常说的5寸手机、4寸手机中的5和4，即对角线的长度。 所以，一样是5寸的手机，分辨率越高，dpi越高。分辨率相同，屏幕对角线英寸数越小，dpi越高。
重点：dp = px*(dpi/160) 再像素密度为160的屏幕上1dp = 1px
   hdpi	160dpi-240dpi	800*480 (Wide VGA)	1dp = 1.5px
   xhdpi	240dpi-320dpi	1280*720	           1dp = 2px
   xxhdpi	320dpi-480dpi	1920*1080	           1dp = 3px
   xxxhdpi	480dpi-640dpi	3840*2160	           1dp = 4px

//依赖
在都是本地依赖的前提下
api依赖是可以传递的，可以形成依赖链，链条上的一个model发生改变，整个链条上的model都要重新编译；
model的implementation对外是隐藏的，model改变后只需编译和它有implementation关系的model；
api是对外公开的，implementation是内部实现，对外隐藏的

//JSONObject 底层是通过HashMap保存键值对，是Android原生的类，构造方法中可以传Map，String, 底层是HashMap所以有keys（）,keySet（）方法。
  JsonObject 底层是通过LinkedTreeMap保存键值对，需要添加gson jar包，有size（）方法。
  
//Android资源文件分为两种
  1，res下资源会被编译，生成编译后的资源问价，和R.java类（资源字典，每个资源有唯一id）
  2, assets下资源不会被编译，反编译后可以拿到这些资源文件
     FileInputStream in = context.getResources().getAssets().open("a.txt"); 读取文件
     String[] fileList = context.getResources().getAssets().list("dirPath")
     
//Style 针对窗体元素级别 view layout
  Theme 针对窗体级别的 activity

//final和static
  final变量：
    如果是基本数据类型的变量，被初始化后不能更改，所以final修饰的成员成员变量是一个常量了。
    如果是引用数据类型变量，被初始化后不能再让其只想另外一个对象，指像的当前对象是的内容是可以修改的

  final修饰的类不能被继承，被修饰的方法不能够重写。

  static修饰的成员变量和成员方法，被类的所有对象所共享，独立于类的对象，在内存中只有一份，在类初次加载时被初始化，Java虚拟机就能根据类名在运行时数据区的方法区内找到他们。

  static int a=1;
  static final b=1;
  这里a和b的区别在于，a在程序里可以被重新赋值为2或3或等等的整数，而b在程序里不能被重新赋值，b永远都为1，也就是说b是一个常量。
  final int c=1;
  static final b=1;
  这里c和b的区别在于，b存放在静态空间，不会在程序运行时被释放，jvm会根据类名找到它（要使用当然是要找到它，最长生命周期的单利😄），它永远占着内存直到程序终止，而c在程序用完它而不会再用到它的时候就会被自动释放，不再占用内存。

  static，final修饰一个HashMap用来保存配置特别好😯，引用更古不变，又可以修改这个map对象，只要关联的类被加载一次，运行期间还不被释放，只要运行就永生不灭，最长的生命周期

//绝对路径和相对路径
  绝对路径 Mac /Users/zhengjingfeng/Desktop/a.txt
          windows D:\Java\main\test.jav
  相对路径(https://www.jianshu.com/p/28fb388030fd)
         同一个目录下
         不同的目录下  ../text.java   ../src/text.java上一级目录 （相对路径的目录分隔符是用“/”，与绝对路径方向相反）
