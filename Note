数据结构 1，存储数据的集合 2，存储的数据之间有特殊关系

初阶数据结构 1，数组(Array)
           2，链表(Linked List) 链表三要素(元素 元素地址 指针)
           3,堆栈(Stack)
           4，队列(Queue)
           常用数据结构是线性结构

高阶数据结构 1，树(Tree) 2,集(Set) 3, 映射(Map) 4,图(Graph) 非线性结构

1个int占4个字节，一个byte占一个字节空间，一个字节占8位，byte的取之范围-128～127，因为第八位为符号为。1KB = 1024B 1B = 8bit

//git init  把一个文件夹变成git本地仓库
//git status
// git add(文件名) 把文件修改添加到暂存区
//git checkout -- Note.txt 撤销缓存区修改  git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。
// git commit（把add的代码提交到分支）把暂存区的所有内容添加到当前分支
//git log 提交日志
//git reset --Hard HEAD^ 回退上一个版本

git init
git add README.md
git commit -m "first commit"
git remote add origin git@github.com:zhengjingfeng/git.git
git push -u origin master

查看分支：git branch

创建分支：git branch <name>

切换分支：git checkout <name>

创建+切换分支：git checkout -b <name>

合并某分支到当前分支：git merge <name>

删除分支：git branch -d <name>

// git clone git branch git -- help(查看命令)
// git checkout(剪出分支)
//fork/clone(add commit push)

清空git缓存
git rm -r --cached .
git add .
git commit -m 'update .gitignore'

//网络请求开始
http 请求3位的返回码中 3开头是重定向，4开头代表客服端错误（404页面：file not found），5开头代表服务器错误，当然200是正常响应
cookie是客服端保持状态的方案 session是在服务端保持状态的方案

域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户

//不同事件监听的优先级
1.onTouch返回true，则onTouchEvent和onClick都不会执行；
2.onTouch(onTouchListener)返回false，如果onTouchEvent不是返回super.onTouchEvent(event);
  也就算是说不管onTouchEvent返回true还是false，onClick(onCLickListener)都不会执行，
  这可以从super的源码看出（源码里会进行判断执行到OnCLickListener）,而且我们知道onClick执行也就会在触摸抬起(up)的时候执行；

//Android的UI操作是线程不安全的
线程安全：
多个线程访问时，采用枷锁的机制，当一个线程访问类的某个数据时，进行保护，其它线程不能访问，当前线程执行完毕后，其它线程才能访问。不会出现数据错乱不一致或数据污染
线程不安全：
不采用枷锁机制，多个线程可以同时访问，可能会造成多个线程都在修改数据造成所得到的数据是脏数据

//单位转换（这次看懂了，不想再看第二遍了）
px:像素 手机的分辨率 如：小米8的分辨率为 2248*1080 1px代表屏幕上的一个像素点。
dip:dots per inch 对角线每英寸对应的像素点。dpi = \dfrac{\sqrt{height^2 + width^2}}{size}。
    height和width即为长宽的像素，平方和即为对角线的像素个数，size即我们常说的5寸手机、4寸手机中的5和4，即对角线的长度。 所以，一样是5寸的手机，分辨率越高，dpi越高。分辨率相同，屏幕对角线英寸数越小，dpi越高。
重点：dp = px*(dpi/160) 再像素密度为160的屏幕上1dp = 1px
   hdpi	160dpi-240dpi	800*480 (Wide VGA)	1dp = 1.5px
   xhdpi	240dpi-320dpi	1280*720	           1dp = 2px
   xxhdpi	320dpi-480dpi	1920*1080	           1dp = 3px
   xxxhdpi	480dpi-640dpi	3840*2160	           1dp = 4px

//依赖
在都是本地依赖的前提下
api依赖是可以传递的，可以形成依赖链，链条上的一个model发生改变，整个链条上的model都要重新编译；
model的implementation对外是隐藏的，model改变后只需编译和它有implementation关系的model；
api是对外公开的，implementation是内部实现，对外隐藏的

//JSONObject 底层是通过HashMap保存键值对，是Android原生的类，构造方法中可以传Map，String, 底层是HashMap所以有keys（）,keySet（）方法。
  JsonObject 底层是通过LinkedTreeMap保存键值对，需要添加gson jar包，有size（）方法。
  
//Android资源文件分为两种
  1，res下资源会被编译，生成编译后的资源文件，和R.java类（资源字典，每个资源有唯一id）
  2, assets下资源不会被编译，反编译后可以拿到这些资源文件
     FileInputStream in = context.getResources().getAssets().open("a.txt"); 读取文件
     String[] fileList = context.getResources().getAssets().list("dirPath")
     
//Style 针对窗体元素级别 view layout
  Theme 针对窗体级别的 activity

//final和static
  final变量：
    如果是基本数据类型的变量，被初始化后不能更改，所以final修饰的成员成员变量是一个常量了。
    如果是引用数据类型变量，被初始化后不能再让其只想另外一个对象，指像的当前对象是的内容是可以修改的

  final修饰的类不能被继承，被修饰的方法不能够重写。

  static修饰的成员变量和成员方法，被类的所有对象所共享，独立于类的对象，在内存中只有一份，在类初次加载时被初始化，Java虚拟机就能根据类名在运行时数据区的方法区内找到他们。

  static int a=1;
  static final b=1;
  这里a和b的区别在于，a在程序里可以被重新赋值为2或3或等等的整数，而b在程序里不能被重新赋值，b永远都为1，也就是说b是一个常量。
  final int c=1;
  static final b=1;
  这里c和b的区别在于，b存放在静态空间，不会在程序运行时被释放，jvm会根据类名找到它（要使用当然是要找到它，最长生命周期的单利😄），它永远占着内存直到程序终止，而c在程序用完它而不会再用到它的时候就会被自动释放，不再占用内存。

  static，final修饰一个HashMap用来保存配置特别好😯，引用更古不变，又可以修改这个map对象，只要关联的类被加载一次，运行期间还不被释放，只要运行就永生不灭，最长的生命周期

//绝对路径和相对路径
  绝对路径 Mac /Users/zhengjingfeng/Desktop/a.txt
          windows D:\Java\main\test.jav

  相对路径(https://www.jianshu.com/p/28fb388030fd)
         同一个目录下
         不同的目录下  ../text.java   ../src/text.java上一级目录 （相对路径的目录分隔符是用“/”，与绝对路径方向相反）

//观察者模式，你在我这里注册，我就持有你的实例，我就可以调你的方法，类似于接口回调。（注册/反注册/通知）其实很简单！！！
  你订阅一份杂志，杂志公司持有你的实例（你的邮箱），当然可以给你发送新的杂志了，简单的一匹。

//泛型好处
  编译期类型检查，减少出错的机会，省去类型强转的代码。在编译过程中，正确验证泛型结果后，会将泛型的信息擦除，泛型信息不会进入运行阶段。
  ArrayList<? extends Animal> list = new ArrayList<Cat>();

          public class Box<T> {
              private T item;

              public T getItem() {
                  return item;
              }

              public void setItem(T item) {
                  this.item = item;
              }
          }

          Box<String> box = new Box<>();//泛型类在实例化的时候确定泛型类型

String s1 = new String("s1") ;
String s2 = new String("s1") ;
上面创建了几个String对象?
答案:3个 ,编译期Constant Pool中创建1个"s1",运行期heap中创建2个.（用new创建的每new一次就在堆上创建一个对象，用引号创建的如果在常量池中已有就直接指向，不用创建）

//今天才弄明白，真实服了
    <TextView
        android:id="@+id/sample_text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World!"/>

        layout_width 是父容器容许view占有的宽度；view还有一个width属性是view自身的宽度。

        //摘抄
        我们在写布局文件的时候，声明控件的时候layout_width和layout_height是控件必须的属性。其实控件还有一个width属性，
        只不过我们一般不需要设置它。虽然我们不常用，但是我们也有必要去了解它。
	首先我们应该知道一个控件的大小并不是由它自己本身来决定的，而是由父布局和它自身一起来决定的。
	layout_width就是父布局允许view所占的宽度，而width是view的自身宽度。
        在layout_width和width都设置为具体数值的时候，width其实就无效了，这也不难理解，父布局已经给你分配了具体的空间，
        不论view怎么设置width，view的宽度也只能是layout_width.
	那么什么情况下，width也会起作用呢。
	当我们把layout_width设置成wrap_content的时候，父布局的意思是包裹view，view有多大就分配多大的空间给它，
        这时候view的宽度就取决于width，假如不设置width，那么系统就会根据view的内容来自行测量大小。
        layout_height和height是一样的。
        同时建议大家也试一下minWidth maxWidth这些属性，可以更好的帮助我们理解布局文件的原理。
        
tip:
onHiddenChange方法可用来刷洗show和hide方式显示和隐藏起来的fragment


https://gofans.cn/app/61bd8db6-e98e-4eaf-bba7-2f77f733bc2a
https://gofans.cn/app/26004a30-1a03-4353-9176-955d67d21609

<merge> 合并融合
LayoutInflater遇见<merge>标签时,就会跳过<merge>标签并且把<merge>标签的子view添加到<merge>标签的父view中.

//布局填充
LayoutInflater加载布局时的inflate方法的第三个参数attachToRoot

如果root为null，无论attachToRoot为true或者false，效果都是一样的
如果root不为null，attachToRoot为true，表示将layout布局添加到root布局中
if (root != null && attachToRoot) {
    root.addView(temp, params);
}
如果root不为null，attachToRoot为false，表示不将layout布局添加到root布局，若要添加则需要手动addView

如果root不为null，而attachToRoot为false的话，表示不将第一个参数所指定的View添加到root中，那么这个时候有的小伙伴可能就有疑问了，既然不添加到root中，那我还写这么多干嘛？我第二个参数直接给null不就可以了？其实不然，这里涉及到另外一个问题：我们在开发的过程中给控件所指定的layout_width和layout_height到底是什么意思？该属性的表示一个控件在容器中的大小，就是说这个控件必须在容器中，这个属性才有意义，否则无意义。这就意味着如果我直接将linearlayout加载进来而不给它指定一个父布局，则inflate布局的根节点的layout_width和layout_height属性将会失效（因为这个时候linearlayout将不处于任何容器中，那么它的根节点的宽高自然会失效）。如果我想让linearlayout的根节点有效，又不想让其处于某一个容器中，那我就可以设置root不为null，而attachToRoot为false。这样，指定root的目的也就很明确了，即root会协助linearlayout的根节点生成布局参数，只有这一个作用。

https://www.cnblogs.com/whoislcj/p/5714760.html//组合控件

https://blog.csdn.net/ceovip/article/details/88922528
在Project的gradle.properties文件中，一些配置信息都可以在Module的build.gradle文件中读取到。
作为application或者module时，AndroidManifest.xml是不一样的

1.Command+W（Window） 关闭单个窗口
2.Command+Q（Quit） 关闭应用并结束应用进程
3.Command+Option+Esc 强制关闭应用

性能优化：常见内存泄漏（L3_02）  工具（Profiler LeakCanary hint）
   单利 内部类（handler 弱引用）不需要的监听移除 不需要的资源即时释放（bitmap cursor broadcast IO流）

渲染优化：卡顿是怎么造成的
    卡主线程（卡UI线程）  60fps 16ms完成（逻辑 cpu gpu）  垂直刷型 GPU OpenGL
    1.某一个函数执行时间比较长，卡主线程；2.频发的GC操作造成主线程卡住

    GPU优化：UI渲染优化（cpu通过计算，把要渲染的模型和纹理信息传递给gpu进行栅格化） 避免过度绘制 屏幕上的某个像素点在同一帧的内被绘制了多次。
    	    优化：去掉多余的背景，自定义的控件裁剪。
	    过度绘制程度（蓝色，绿色，粉色，红色）
    CPU优化：<ViewStub> 避免视图嵌套过深

Bitmap优化：（bitmap图片在内存中的存在形式）
    图片存在的几种形式（1.File 2.流的形式bytes 3.bitmap形式——内存）

    一个像素点包含四个信息 argb

AS自带优化工具
    Android profiler（分析）   inspect code   layout inspector（检查 巡视）


Handler机制：
    ActivityThread是Android程序的入口。里面有main方法 {
            public static void main(String[] args) {
                Looper.prepareMainLooper();//主线程自少有一个Looper对象
                //......
                Looper.loop();
            }
        }

    public static prepareMainLooper() {
        prepare;
    }

    ThreadLocal:线程隔离用的；

    public static void prepare(){
        sThreadLocal.set(new Looper());
    }

    public static Looper myLooper() {
        return sThreadLoacl.get();
    }

    public static loop() {
        Looper me = myLooper();
	//...
	final MessageQueue queue = me.mQueue;
	//...
	for(;;){
		Message msg = queue.next();//next() 方法返回一个msg
	}
    }

    public Hanlder() {
        this.(null,false);
    }

    public Handler(CallBack call, ) {
        //...
        mLooper = Looper.myLooper(); //从ThreadLocal中取出looper
        mQueue = mLooper.mQueue;
        //mCallback = callback;
        //mAsynchronous = async;
    }
    
    public final boolean sendMessage(Message msg) 
    	//...
    }
    
    sendMessage->sendMessageDelayed -> sendMessageAtTime
    
    public boolean sendMessageAtTime(Message msg, long upTimeMillis) {
    	Message queue = mQueue;
	if(queue == null) {
		//...
		return false;
	}
	returen enqueueMesaage(queue, msg, upTimeMillis);
    }
    
    private boolean enqueueMesaage(MessageQueue queue, Message msg, long upTimeMillis) {
    	msg.target = this;//this 是Handler
	return queue.enqueueMessage(queue, upTimeMillis);
    }

//Lock锁的使用
lock = new ReentrantLock();

condition = lock.newCondition();

	try {
        	lock.lock();
		} finally {
  			lock.unlock();
		}
	condition.await();
	condition.signal();

安装包性能优化：
    常规压缩：
    图片：webp：谷歌提倡使用，保存图片比较小，webp的无损压缩比png小45%，缺点：加载速度比png慢很多
    lint工具：1，检查未使用的布局 删除  2，未使用的资源（图片）删除 3，String.xml没有用到的字符
    7zip压缩：
    proguard 混淆 让apk变小：1，删掉注释和不实用的代码；2，Java文件名字和方法名改短（a.java）

热修复：Android是如何加载classes.dex，启动程序的？
    AndFix(底层二进制入手) Tinker（类加载机制入手）
    1,PathClassLoader
        用来加载应用程序的dex
    2,PathClassLoader
        可以加载某个指定的dex（限制：必须是应用程序目录下的,包名目录下）

    BaseDexClassLoad{
        Class<?> findClass(String className){
		Class c = pathList.findClass(name, suppressedExceptions);//DexPathList.findClass()
	}
    }
    
    //DexPathList类
      ublic Class<?> findClass(String name, List<Throwable> suppressed) {
         for (Element element : dexElements) {//遍历dexElements，热修复就是把新的dex加入到dexElements集合里面。
             Class<?> clazz = element.findClass(name, definingContext, suppressed);
             if (clazz != null) {
                 return clazz;//找到了就返回，热修复把包含修改后的class的dex加入到dexElements集合里面最前面就可以，应该找到那个正确的claZZ就返回。。
             }
         }

         if (dexElementsSuppressedExceptions != null) {
             suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));
         }
         return null;


    BaseDexClassLoader->DexPathList pathList 字段->  Element[] DexElements 字段是我们需要的。

动脑学院 腾讯学院
趋势：kotlin rn 车载 VR Ai；对基础内容深入理解，尽快向高级水平靠近和达到，第二步再找准定位和细分领域。这个英文水平是个什么情况？？？

short索引dex文件中的方法数，受到short取值范围的影响，方法不能超过65535。

数据结构与算法：
    数据结构：集合结构，线性结构，树形结构，图形结构
    
    private static class Node<E> {
    	E item;
	Node<E> prev;
	Node<E> next;
	
	Node(Node<E> prev,E element,Node<E> next) {
		    this.item = elements;
		    this.prev = prev;
		    this.next = next;
	    }
    }

    ArrayList LinkedList Vector->stack，vector和stack是线程安全的，queue
    集合里的迭代器 很简单，看一下ArrayList 的 Iterator，很简单

    HashMap(散列链表)：    transient Node<K,V>[] table; 散列链表

    键值对的 index 有key 的hash值和键值对数组的长度两个因素决定

    int index = hash(key)&(tab.length() - 1);//tab 是键值对数组

    lru算法：LinkedHashMap

    树；比如window的文件系统。子节点只有一个父节点

    二叉树：二分查找法，最多两个子节点

            try {
                Class.forName("").newInstance();//说明forName()是一个静态方法,newInsTance()是一个native方法
            } catch (Exception e) {
                e.printStackTrace();
            }


设计模式：说白了就是套路
    简单工厂：场景：创建对象，降低客服端与模块之间的耦合（最少知识原则）
    工厂方法模式：把具体的实现延迟到子类
    抽象工厂模式：每个工厂只生产一种产品，产品族
    原型模式：

APP的启动流程：启动图标->Main(ActivityThread)->attahc(false)->IActivityManager mgr = ActivityManager.getService()/---
                final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
                                    final IActivityManager am = IActivityManager.Stub.asInterface(b);
                                    return am;---/
             ->mgr.attachApplication(mAppThread, startSeq);

开发的时候将所有的单利放到一个HashMap里面管理

动态权限  get //https://droidyue.com/blog/2016/01/17/understanding-marshmallow-runtime-permission/

    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }

接口回调是一种主动行的API，控制反转，谁定义这个接口，然后调用，就掌握主动权。

//astah 的使用 上班期间学会

六大设计原则：//https://www.cnblogs.com/dolphin0520/p/3919839.html
    1，单一职责：只有一个引起变化的原因
    2，开闭原则：对扩开放，对修改关闭，即在尽量不修改原有代码的情况下对代码进行扩展。
    3，里氏替换原则：所有引用基类的地方都必须能透明地使用子类对象，尽量把基类设计成抽象类或接口。里氏替换原则是开闭原则的实现方式之一。
    4，依赖倒置原则：针对接口编程，不针对实现编程。使用抽象类和接口进行变量申明，参数申明，返回值申明。调用的时候具体对象通过依赖注入（构造注入，设置注入setter，接口注入）
       等等，开闭原则是目标，里氏替换原则是基础，依赖倒置原则是手段。
    5，接口隔离原则：拒绝大接口，使用小接口，客服端不应该依赖它们不需要的接口。
    6，迪米特法则：降低耦合，一个对象的改变不会其它太多对象带来影响；可以通过引入桥梁来通讯，降低对象自建的耦合度；耦合度越低越有利于复用。//海贼王472集

Android 动画
    1，栅格图：也叫位图，放大失真，GPU绘制
    2，矢量图：放大不失真，CPU绘制

    补间动画：new XXAnimator()；XXAnimator.setDurtion()；View.startAnimater(XXAnimator);
    帧动画：animation = new AnimationDrawable()；animation.addFrame(draw,100)；View.setImaeDrawable(animation)；animation.start()。
    属性动画：不断的改变属性值来实现的，初始值和结束值中间的值是插值。
            ValueAnimator animator = ValueAnimator.foInt(0,20);
            animator.setDuration(2000);
            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(v->{public void onAnimatorUpdate{}}));
            animator.start();
            Valueanimator只是帮我们计算除了动画过程中的一些插值，并没有让我门看到任何动画效果。
            public static ValueAnimator ofInt(int... values) {
                    ValueAnimator anim = new ValueAnimator();
                    anim.setIntValues(values);
                    return anim;
                }
            public static ObjectAnimator ofInt(Object target, String propertyName, int... values) {
                    ObjectAnimator anim = new ObjectAnimator(target, propertyName);
                    anim.setIntValues(values);
                    return anim;
                }

            ObjectAnimator才是最常用的类，可以对任何对象的任何属性进行操作，来实现真的动画。


CompileSdkVersion和BuildToolVersion
1,CompileSdkVersion是你SDK的版本号，也就是API Level，例如API-19、API-20、API-21等等。
2,buildeToolVersion是你构建工具的版本，其中包括了打包工具aapt、dx等等。这个工具的目录位于..your_sdk_path/build-tools/XX.XX.XX
3,可以用高版本的build-tool去构建一个低版本的sdk工程，例如build-tool的版本为28，去构建一个sdk版本为27的

Android 组件化
    以前的分包变成了现在的模块
    Arouter:（A->B ）
        注册 B界面将类的信息通过key_value的形式注册到Arouter中
        查询 通过key获取目标界面信息
        关联
        跳转
