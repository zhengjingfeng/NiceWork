数据结构 1，存储数据的集合 2，存储的数据之间有特殊关系初阶数据结构 1，数组(Array)           2，链表(Linked List) 链表三要素(元素 元素地址 指针)           3,堆栈(Stack)           4，队列(Queue)           常用数据结构是线性结构高阶数据结构 1，树(Tree) 2,集(Set) 3, 映射(Map) 4,图(Graph) 非线性结构1个int占4个字节，一个byte占一个字节空间，一个字节占8位，byte的取之范围-128～127，因为第八位为符号为。1KB = 1024B 1B = 8bit//网络请求开始http 请求3位的返回码中 3开头是重定向，4开头代表客服端错误（404页面：file not found），5开头代表服务器错误，当然200是正常响应cookie是客服端保持状态的方案 session是在服务端保持状态的方案域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，	并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户//不同事件监听的优先级1.onTouch返回true，则onTouchEvent和onClick都不会执行；2.onTouch(onTouchListener)返回false，如果onTouchEvent不是返回super.onTouchEvent(event);  不管onTouchEvent返回true还是false，onClick(onCLickListener)都不会执行，  这可以从super的源码看出（源码里会进行判断执行到OnCLickListener）,而且我们知道onClick执行也就会在触摸抬起(up)的时候执行；//Android的UI操作是线程不安全的线程安全：多个线程访问时，采用枷锁的机制，当一个线程访问类的某个数据时，进行保护，其它线程不能访问，当前线程执行完毕后，其它线程才能访问。	不会出现数据错乱不一致。线程不安全：不采用枷锁机制，多个线程可以同时访问，可能会造成多个线程都在修改数据造成所得到的数据不一致。//单位转换（这次看懂了，不想再看第二遍了）px:像素 手机的分辨率 如：小米8的分辨率为 2248*1080 1px代表屏幕上的一个像素点。dpi:dots per inch 对角线每英寸对应的像素点。dpi = \dfrac{\sqrt{height^2 + width^2}}{size}。    height和width即为长宽的像素，平方和即为对角线的像素个数，size即我们常说的5寸手机、4寸手机中的5和4，即对角线的长度。    	所以，一样是5寸的手机，分辨率越高，dpi越高。分辨率相同，屏幕对角线英寸数越小，dpi越高。重点：dp = px*(dpi/160) 再像素密度为160的屏幕上1dp = 1px   hdpi	160dpi-240dpi	800*480 (Wide VGA)	1dp = 1.5px   xhdpi	240dpi-320dpi	1280*720	           1dp = 2px   xxhdpi	320dpi-480dpi	1920*1080	           1dp = 3px   xxxhdpi	480dpi-640dpi	3840*2160	           1dp = 4px//依赖在都是本地依赖的前提下api依赖是可以传递的，可以形成依赖链，链条上的一个model发生改变，整个链条上的model都要重新编译；model的implementation对外是隐藏的，model改变后只需编译和它有implementation关系的model；api是对外公开的，implementation是内部实现，对外隐藏的//JSONObject 底层是通过HashMap保存键值对，是Android原生的类，构造方法中可以传Map，String, 底层是HashMap所以有keys（）,keySet（）方法。  JsonObject 底层是通过LinkedTreeMap保存键值对，需要添加gson jar包，有size（）方法。  //Android资源文件分为两种  1，res下资源会被编译，生成编译后的资源文件，和R.java类（资源字典，每个资源有唯一id）  2, assets下资源不会被编译，反编译后可以拿到这些资源文件     FileInputStream in = context.getResources().getAssets().open("a.txt"); 读取文件     String[] fileList = context.getResources().getAssets().list("dirPath")     //Style 针对窗体元素级别 view layout  Theme 针对窗体级别的 activity//final和static  final变量：    如果是基本数据类型的变量，被初始化后不能更改，所以final修饰的成员成员变量是一个常量了。    如果是引用数据类型变量，被初始化后不能再让其指向另外一个对象，指像的当前对象是的内容是可以修改的  final修饰的类不能被继承，被修饰的方法不能够重写。  static修饰的成员变量和成员方法，被类的所有对象所共享，独立于类的对象，在内存中只有一份，在类初次加载时被初始化，  	Java虚拟机就能根据类名在运行时数据区的方法区内找到他们。  static int a=1;  static final b=1;  这里a和b的区别在于，a在程序里可以被重新赋值为2或3或等等的整数，而b在程序里不能被重新赋值，b永远都为1，也就是说b是一个常量。  final int c=1;  static final b=1;  这里c和b的区别在于，b存放在静态空间，不会在程序运行时被释放，jvm会根据类名找到它（要使用当然是要找到它，最长生命周期的单利😄），  	它永远占着内存直到程序终止，而c在程序用完它而不会再用到它的时候就会被自动释放，不再占用内存。  static，final修饰一个HashMap用来保存配置特别好，引用更古不变，又可以修改这个map对象，只要关联的类被加载一次，运行期间还不被释放，  	只要进程没有退出就永生不灭，最长的生命周期//绝对路径和相对路径  绝对路径 Mac /Users/zhengjingfeng/Desktop/a.txt          windows D:\Java\main\test.jav  相对路径(https://www.jianshu.com/p/28fb388030fd)         同一个目录下         不同的目录下  ../text.java   ../src/text.java上一级目录 （相对路径的目录分隔符是用“/”，与绝对路径方向相反）//观察者模式，你在我这里注册，我就持有你的实例，我就可以调你的方法，类似于接口回调。（注册/反注册/通知）其实很简单！！！  你订阅一份杂志，杂志公司持有你的实例（你的邮箱），当然可以给你发送新的杂志了，简单的一匹。//泛型好处  编译期类型检查，减少出错的机会，省去类型强转的代码。在编译过程中，正确验证泛型结果后，会将泛型的信息擦除，泛型信息不会进入运行阶段。  ArrayList<? extends Animal> list = new ArrayList<Cat>();          public class Box<T> {              private T item;              public T getItem() {                  return item;              }              public void setItem(T item) {                  this.item = item;              }          }          Box<String> box = new Box<>();//泛型类在实例化的时候确定泛型类型String s1 = new String("s1") ;String s2 = new String("s1") ;上面创建了几个String对象?答案:3个 ,编译期Constant Pool中创建1个"s1",运行期heap中创建2个.（每new一次就在堆上创建一个对象，用引号创建的如果在常量池中已有就直接指向，	不用创建）//今天才弄明白，真实服了    <TextView        android:id="@+id/sample_text"        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:text="Hello World!"/>        layout_width 是父容器容许view占有的宽度；view还有一个width属性是view自身的宽度。        //摘抄        我们在写布局文件的时候，声明控件的时候layout_width和layout_height是控件必须的属性。其实控件还有一个width属性，        只不过我们一般不需要设置它。虽然我们不常用，但是我们也有必要去了解它。	首先我们应该知道一个控件的大小并不是由它自己本身来决定的，而是由父布局和它自身一起来决定的。	layout_width就是父布局允许view所占的宽度，而width是view的自身宽度。        在layout_width和width都设置为具体数值的时候，width其实就无效了，这也不难理解，父布局已经给你分配了具体的空间，        不论view怎么设置width，view的宽度也只能是layout_width.	那么什么情况下，width也会起作用呢。	当我们把layout_width设置成wrap_content的时候，父布局的意思是包裹view，view有多大就分配多大的空间给它，        这时候view的宽度就取决于width，假如不设置width，那么系统就会根据view的内容来自行测量大小。        layout_height和height是一样的。        同时建议大家也试一下minWidth maxWidth这些属性，可以更好的帮助我们理解布局文件的原理。        tip:onHiddenChange方法可用来刷新show和hide方式显示和隐藏起来的fragment<merge> 合并融合	LayoutInflater遇见<merge>标签时,就会跳过<merge>标签并且把<merge>标签的子view添加到<merge>标签的父view中.//布局填充LayoutInflater加载布局时的inflate方法的第三个参数attachToRoot如果root为null，无论attachToRoot为true或者false，效果都是一样的如果root不为null，attachToRoot为true，表示将layout布局添加到root布局中if (root != null && attachToRoot) {    root.addView(temp, params);}如果root不为null，attachToRoot为false，表示不将layout布局添加到root布局，若要添加则需要手动addView如果root不为null，而attachToRoot为false的话，表示不将第一个参数所指定的View添加到root中，那么这个时候有的小伙伴可能就有疑问了，	既然不添加到root中，那我还写这么多干嘛？我第二个参数直接给null不就可以了？	其实不然，这里涉及到另外一个问题：我们在开发的过程中给控件所指定的layout_width和layout_height到底是什么意思？	该属性的表示一个控件在容器中的大小，就是说这个控件必须在容器中，这个属性才有意义，否则无意义。	这就意味着如果我直接将linearlayout加载进来而不给它指定一个父布局，	则inflate布局的根节点的layout_width和layout_height属性将会失效（因为这个时候linearlayout将不处于任何容器中，	那么它的根节点的宽高自然会失效）。如果我想让linearlayout的根节点有效，又不想让其处于某一个容器中，那我就可以设置root不为null，	而attachToRoot为false。这样，指定root的目的也就很明确了，即root会协助linearlayout的根节点生成布局参数，只有这一个作用。https://www.cnblogs.com/whoislcj/p/5714760.html//组合控件在Project的 gradle.properties 文件中，一些配置信息都可以在Module的build.gradle文件中读取到。作为application或者module时，AndroidManifest.xml是不一样的性能优化：常见内存泄漏（L3_02）  工具（Android Profiler LeakCanary hint）   单利 非静态内部类（handler 静态+弱引用）不需要的监听移除 不需要的资源即时释放（bitmap cursor broadcast IO流）   WebView:申请Native堆内存 把WebView所在的activity放在一个单独的进程，之后可以杀掉这个进程(在destroy（）方法中 ) android.os.Process.killProcess(android.od.Process.myPid())渲染优化：卡顿是怎么造成的    卡主线程（卡UI线程）  60fps 16ms完成（逻辑 cpu gpu）  垂直刷型 GPU OpenGL    1.某一个函数执行时间比较长，卡主线程；2.频发的GC操作造成主线程卡住    GPU优化：UI渲染优化（cpu通过计算，把要渲染的模型和纹理信息传递给gpu进行栅格化） 避免过度绘制 屏幕上的某个像素点在同一帧的内被绘制了多次。    	    优化：去掉多余的背景，自定义的控件裁剪。	    过度绘制程度（蓝色，绿色，粉色，红色）    CPU优化：<ViewStub> <marge>避免视图嵌套过深Bitmap优化：（bitmap图片在内存中的存在形式）    图片存在的几种形式（1.File 2.流的形式bytes 3.bitmap形式——内存）    一个像素点包含四个信息 argbAS自带优化工具    Android profiler（分析）   inspect code(Lint)   layout inspector（检查 巡视）Handler机制：    ActivityThread是Android程序的入口。里面有main方法 {            public static void main(String[] args) {                Looper.prepareMainLooper();//主线程自少有一个Looper对象                //......                Looper.loop();            }        }    public static prepareMainLooper() {        prepare;    }    ThreadLocal:线程隔离用的；    public static void prepare(){        sThreadLocal.set(new Looper());    }    public static Looper myLooper() {        return sThreadLoacl.get();    }    public static loop() {        Looper me = myLooper();	//...	final MessageQueue queue = me.mQueue;//loop构造方法初始化Queue	//...	for(;;){		Message msg = queue.next();//next() 方法返回一个msg	}    }    public Hanlder() {        this.(null,false);    }    public Handler(CallBack call, Boolean b){        //...        mLooper = Looper.myLooper(); //从ThreadLocal中取出looper,静态方法，获取当前线程的looper对象        mQueue = mLooper.mQueue;        //mCallback = callback;        //mAsynchronous = async;    }        public final boolean sendMessage(Message msg)     	//...    }        sendMessage->sendMessageDelayed -> sendMessageAtTime        public boolean sendMessageAtTime(Message msg, long upTimeMillis) {    	Message queue = mQueue;	if(queue == null) {		//...		return false;	}	returen enqueueMesaage(queue, msg, upTimeMillis);    }        private boolean enqueueMesaage(MessageQueue queue, Message msg, long upTimeMillis) {    	msg.target = this;//this 是Handler	return queue.enqueueMessage(queue, upTimeMillis);    }//Lock锁的使用lock = new ReentrantLock();condition = lock.newCondition();	try {        	lock.lock();		} finally {  			lock.unlock();		}	condition.await();	condition.signal();安装包性能优化：    常规压缩：    图片：webp：谷歌提倡使用，保存图片比较小，webp的无损压缩比png小45%，缺点：加载速度比png慢很多    Lint工具：1，检查未使用的布局 删除  2，未使用的资源（图片）删除 3，String.xml没有用到的字符    7zip压缩：    proguard 混淆 让apk变小：1，删掉注释和不使用的代码；2，Java文件名字和方法名改短（a.java）热修复：Android是如何加载classes.dex，启动程序的？    AndFix(底层二进制入手) Tinker（类加载机制入手）    1,PathClassLoader        用来加载应用程序的dex    2,DexClassLoader        可以加载某个指定的dex（限制：必须是应用程序目录下的,包名目录下）    BaseDexClassLoad{        Class<?> findClass(String className){		    Class c = pathList.findClass(className, suppressedExceptions);//DexPathList.findClass()；		}	}        //DexPathList类      pblic Class<?> findClass(String name, List<Throwable> suppressed) {         for (Element element : dexElements) {//遍历dexElements，热修复就是把新的dex加入到dexElements集合里面。             Class<?> clazz = element.findClass(className, definingContext, suppressed);             if (clazz != null) {                return clazz;//找到了就返回，热修复把包含修改后的class的dex加入到dexElements集合里面最前面就可以，找到那个修改后的class就返回。。             }         }         if (dexElementsSuppressedExceptions != null) {             suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));         }         return null;    BaseDexClassLoader->DexPathList pathList 字段->  Element[] DexElements 字段是我们需要的。动脑学院 腾讯学院趋势：kotlin rn 车载 VR Ai；对基础内容深入理解，尽快向高级水平靠近和达到，第二步再找准定位和细分领域。这个英文水平是个什么情况？？？short索引dex文件中的方法数，受到short取值范围的影响，方法不能超过65535。数据结构与算法：    数据结构：集合结构，线性结构，树形结构，图形结构        private static class Node<E> {    	E item;	Node<E> prev;	Node<E> next;		Node(Node<E> prev,E element,Node<E> next) {		    this.item = elements;		    this.prev = prev;		    this.next = next;	    }    }    ArrayList    LinkedList    Vector->stack，vector和stack是线程安全的，queue    集合里的迭代器 很简单，看一下ArrayList 的 Iterator，很简单    HashMap(散列链表)：    transient Node<K,V>[] table; 散列链表    键值对的 index 由key的hash值和键值对数组的长度两个因素决定    int index = hash(key)&(tab.length() - 1);//tab 是键值对数组    lru算法：LinkedHashMap    树；比如window的文件系统。子节点只有一个父节点    二叉树：二分查找法，最多两个子节点            try {                Class.forName("").newInstance();//说明forName()是一个静态方法,newInsTance()是一个native方法            } catch (Exception e) {                e.printStackTrace();            }设计模式：说白了就是套路    简单工厂：场景：创建对象，降低客服端与模块之间的耦合（最少知识原则）    工厂方法模式：把具体的实现延迟到子类    抽象工厂模式：每个工厂只生产一种产品，产品族    原型模式：APP的启动流程：？？？开发的时候将所有的单利放到一个HashMap里面管理动态权限  get //https://droidyue.com/blog/2016/01/17/understanding-marshmallow-runtime-permission/    @Override    public void run() {        if (target != null) {            target.run();        }    }接口回调是一种主动行的API，控制反转，谁定义这个接口，然后调用，就掌握主动权。枚举：一个类的子类有几个已经确定，就把它定义为枚举enum COLOR {        /**         *三原色         */        RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255);        /**         * @param r         * @param g         * @param b         */        COLOR(int r, int g, int b) {        }    }六大设计原则：//https://www.cnblogs.com/dolphin0520/p/3919839.html    1，单一职责：只有一个引起变化的原因    2，开闭原则：对扩开放，对修改关闭，即在尽量不修改原有代码的情况下对代码进行扩展。    3，里氏替换原则：所有引用基类的地方都必须能透明地使用子类对象，尽量把基类设计成抽象类或接口。里氏替换原则是开闭原则的实现方式之一。    4，依赖倒置原则：针对接口编程，不针对实现编程。使用抽象类和接口进行变量申明，参数申明，返回值申明。调用的时候具体对象通过依赖注入    	（构造注入，设置注入setter，接口注入）       等等，开闭原则是目标，里氏替换原则是基础，依赖倒置原则是手段。    5，接口隔离原则：拒绝大接口，使用小接口，客户端端不应该依赖它们不需要的接口。    6，迪米特法则：降低耦合，一个对象的改变不会对其它太多对象带来影响；可以通过引入桥梁来通讯，降低对象自建的耦合度；耦合度越低越有利于复用。Android 动画    1，栅格图：也叫位图，像素点组成，放大失真，GPU绘制，Android中的位图称作bitmap，所以可以通过像素进行compress压缩。    2，矢量图：放大不失真，CPU绘制    补间动画：new XXAnimator()；XXAnimator.setDurtion()；View.startAnimater(XXAnimator);    帧动画：animation = new AnimationDrawable()；animation.addFrame(draw,100)；View.setImaeDrawable(animation)；animation.start()。    属性动画：不断的改变属性值来实现的，初始值和结束值中间的值是插值。            ValueAnimator animator = ValueAnimator.foInt(0,20);            animator.setDuration(2000);            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(v->{public void onAnimatorUpdate{}}));            animator.start();            Valueanimator只是帮我们计算除了动画过程中的一些插值，并没有让我门看到任何动画效果。            public static ValueAnimator ofInt(int... values) {                    ValueAnimator anim = new ValueAnimator();                    anim.setIntValues(values);                    return anim;                }            public static ObjectAnimator ofInt(Object target, String propertyName, int... values) {                    ObjectAnimator anim = new ObjectAnimator(target, propertyName);                    anim.setIntValues(values);                    return anim;                }            ObjectAnimator才是最常用的类，可以对任何对象的任何属性进行操作，来实现真的动画。CompileSdkVersion和BuildToolVersion1,CompileSdkVersion是你SDK的版本号，也就是API Level，例如API-19、API-20、API-21等等。2,buildeToolVersion是你构建工具的版本，其中包括了打包工具aapt、dx等等。这个工具的目录位于..your_sdk_path/build-tools/XX.XX.XX3,可以用高版本的build-tool去构建一个低版本的sdk工程，例如build-tool的版本为28，去构建一个sdk版本为27的Android 组件化    以前的分包变成了现在的组件    公共组件（功能组件）：第三发依赖 常用功能（工具类）自定义控件 基础类 权限 步骤1    业务组件：所有的业务组件依赖依赖公共组件 步骤3    APP壳：对整个项目组件模块进行组装，拼凑成一个完整的APP 步骤5    config.gradle 配置项目中的所有第三方库，APP中的版本号，在工程的build.gradle中引入配置文件 apply from: "config.gradle" 步骤2    业务组件之间没有依赖，不能要用常规的Intent显示进行跳转，需要使用阿里的Arouter，组件间的通信用EventBus.  步骤6    资源文件冲突问题：目前是设置资源前缀  步骤7    如果业务组件需要独立运行，则需要单独配置一份AndroidManifest，在gradle的sourceSets根据不同的模式加载不同的AndroidManifest文件。    	其中集成模式加载的Manifest中不能设置Application和程序入口  步骤4    Arouter:（A->B ）            注册 B界面将类的信息通过key_value的形式注册到Arouter中            查询 通过key获取目标界面信息            关联            跳转    动态代理又看了一遍，面试不要再说错了，弱引用的写法也清除了吧，（引用的对象作为参数传给给弱引用），获取引用的对象用get()方法，socket也看了一遍吧。今天算是取得了一点进步    动态代理代理的是接口，静态代理代理可以代理抽象    Application类的理解：（APP冷启动时加载最先加载）    	Application在一个Dalvik虚拟机里面只有一个实力，一个App有几个进程，就有几个Dalvik虚拟机	    在onCreat()方法里面不要做过多的耗时操作，会影响App的启动速度	    除此之外，由于在Context中可以通过getApplicationContext()获取到Application对象，	    或者是通过Activity.getApplication()、	    Service.getApplication()获取到Application，	    所以可以在Application保存全局的数据，供所有的Activity或者是Service使用。Scoket通信：参考https://blog.csdn.net/pbyang_love/article/details/81676949	Socket提供了程序内部与外界通信的端口并为通信双方提供了数据传输通道。	Socket很简单 两种方式的Socket(TCP/UDP) TCP以流的方式发送数据，UDP以包的形式发送数据。		Java中的网络通信是通过Socket实现的，Socket分为ServerSocket和Socket两大类.		ServerSocket用于服务端，可以通过accept方法监听请求，监听到请求返回Socket;		Socket用于具体完成数据传输，客户端直接使用Socket发起请求并传输数据。			ServerSocket的使用可以分为三步：	1）创建ServerSocket。ServerSocket的构造方法一共有5个，用起来最方便的是ServerSocket（int port）,只需要一个port（端口号）就可以了。	2）调用创建出来的ServerSocket的accept方法进行监听。accept方法是阻塞方法，也就是说调用accept方法后程序会停下来等待连接请求，在接收到请求之前程序将不会往下走，当接收到请求后accept方法会返回一个Socket。	3）使用accept方法返回的Socket与客户端进行通信。		ServerSocket serverSocket = new ServerSocket(111);	Socket socket = serverSocket.accept();		Socket socket = new Socket("111", 111);		长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。		心跳包主要也就是用于长连接的保活和断线处理。弹窗样式：    https://github.com/lingcimi/jjdxm_dialoguiJS调用:    mWebview.addJavascriptInterface(this, "native");    @JavascriptInterface（注解无处不在啊）    public void jsToNative(String type, String locationData) {        if ("shareTo".equals(type)) {            TaskIDBean taskIDBean = new Gson().fromJson(locationData, TaskIDBean.class);            initShareParams(taskIDBean.getTask_id(), taskIDBean.getType());        }    }10大开源框架：（一般看源码不看if（））    okhttp    同步请求只是executed client.disPather.executed(call)-runningSyncCalls.add(call)同步请求的execute只是把请求加入到同步队列    发起异步请求的时候，判断当前正在请求的异步队列是否小于64，网络亲求的host是否小于5，是加入异步执行队列，通过线程池执行这个请求；否加入异步缓存队列    dispather维护同步异步请求状态和一个用于执行请求的线程池    call 的本质就是一个runnable    两大核心：dispather  维护同步和异步网路请求的状态（3队列），同时维护线程池。            interceptor    dispather - asycall -excetor.excete(asycall)                asycall.excete()                chain = realInterceptorChain(interceptorChains,...)                chain.proceed() -> interceptor.intercept(next)->realChain.preceed()    1，封装call对象 2，dispatcher对n请求进行分发 3，getResponceWithInterceptors()    Glide(谷歌官方推荐的图片加载框架)        Glide.with(this).load(utl).into(imageView);        glide : requestManagerRetriever - requestManager(处理请求的管理类，监听整个组件的生命周期 )-DrawableTypeRequest(将图片转换成GIF或者bitmap )    RXJava 响应式编程（比如：下雨打伞，下雨是事件，打伞是响应），异步事件流。        创建被观察者：create just from三种方法请求被执行之后都会在finally中走finish 方法，从runningasyncall中去除掉这个方法，然后把遍历等待队列，把等待队列中的call加入进来        创建观察者：new Observer(){oncompleted,onerror,onnext}        订阅：observable.subscrbe(observer)/observable.subscrbe(subscriber)。        请求被执行之后都会在finally中走finish 方法，从runningasyncall中去除掉这个方法，然后把遍历等待队列，把等待队列中的call加入进来        操作符和线程控制            map操作符：转换操作符，通过映射转化事件（事件指的是数据 ）。            flatMap:            zip:多个observable合并        代理的本质是无侵入（不修改你原来代码的情况下）的争强方法    Dagger2：（解耦，开闭原则）        依赖注入        @Inject(标记成员变量 标记注入的类的构造方法) @Componnent @Module @Provides(前面两个方法是基本使用)    小知识：(方法区 包含class对象和静态变量)        宁愿OOM终止程序也不回收强引用对象；软引用内存不够就回收；弱引用看见就回收；虚引用不会决定对象的生命周期    MAT:    LeakCanary:实时监控activity(吐司 通知栏)        1，activity Destory后 将它放在一个 weakReference        2, 这个weakReference关联到一个referenceQueue        3, 查看这个referenceQueue中是否有这个activity的引用        4，如果内存泄漏会dump出Heap信心，并分析内存泄露路径Android 弹窗 https://github.com/limxing/Android-PromptDialog/kotlin官方博客：https://blog.jetbrains.com/kotlin/kotlin官网https://kotlinlang.org/kotlin:	class persion(name:String, age Int) {		val name by lazy {"张三"}//用的时候在加载（懒加载）	private set		var age = 20	set(value:Int) {		if(value<150) {			field = value		}	}		lateInit var phone:String;//延迟加载，用的时候加载	init{		this.name = name		this.age = age	}	constructor(name String, int age, phone String):this(name, age) {		this.phone = phone	}}	标签处返回tag@	when加强版switch		b:int = a?.toInt():-1	函数表达式：函数体只有一行，可以优化fun add(a:Int,b Int) = a+b;//val padd:(Int,Int)->int = {a,b -> a+b}		函数变量 val padd  = :: add(两个冒号是对函数的引用)	默认参数：fun sendRequest(path String,method String = "GET") {} //method为默认参数，可以不用传	kotlin类默认是final的，要继承open 	关键字 inner class inline（内联） reified operator重载方法 open  ： String::class out接收当前类型或子类 in传当前类型或父类	      lateInit 延迟加载    委托：class smallHeadFather(var warsPower:WarsPower):WarsPower by warsPower    by lazy:懒加载  lateInit 延迟加载    扩展函数：    fun String.isEmpty():Boolean { //扩展String这个类，增加函数isEmpty() 扩展函数可以被子类访问，不能被复写        return this==null||this.size() == 0    }    单利：        object 关键字 默认filed全部是静态 method全部是final    伴生对象：控制属性的静态    class Utils private constructor() {            var age: Int = 20            companion object {                var name: String = "张三"                val instance by lazy { Utils() } //懒加载 只加载线程安全            }        }    数据类：data class{}    密封类：sealed class    List：        listOf();只读        mutableListOf();可读写    函数式编程：        闭包：让函数携带状态    高阶函数与lambda（匿名函数）一般同时出现    https://www.cnblogs.com/mfrbuaa/p/3763560.html    https://www.runoob.com/w3cnote/mqtt-intro.html    面试：    	性能调优 软件架构 （工具链和中间件）UI 网络 测试工具微信支付：	m注册（AppID） 申请权限（微信支付）gradle集成微信支付的SDK	选择商品 请求生成支付订单   APP客户端	请求统一下单API           APP后台	生成预付单 返回预付单信息（prepare_id） 微信支付系统	生成带签名的客户端支付信息 返回信息（LoginPresenter sign） APP后台	用户确认支付	掉用SDK（参数）掉起微信支付 APP客户端	发起支付请求              微信客户端	验证支付参数 支付权限等 返回需要支付授权    微信支付系统	确认支付 输入密码 提交支付授权   微信客户端	验证支付授权 完成支付交易 返回支付结果  微信支付系统	APP回调接口支付状态    APP客户端	去后台查询支付结果  APP客户端	后台返回支付结果  APP后台	商家发货	后台的二次签名	AndroidManifest配置WXPayEnterActivity 权限等	支付资料：	https://www.cnblogs.com/dingxiansen/p/9208949.html突然小知识：    使用AndroidStudio开发的童鞋都知道，JAR包放在项目app的libs目录下，而so库放在main目录的jniLibs目录下，如果没有jniLibs目录就创建一个百度地图：	百度地图SDK集成，其实就2点，第一选择你要的SDK（地图、定位、鹰眼轨迹、导航、全景），解压后将libs复制到app下的libs目录下.APP开发流程：    立项（产品经理吧） 需求文档    原型设计 UI设计    框架搭建 开发    平台账号申请 运营平台 代码混淆 打包上线    先整体按照模块定一个开发周期；    在每周具体安排实现哪些功能和Ui搭建 排出来之后给开发人员看下时间是否需要调整；    每周五再统计完成情况。    武汉？我不喜欢，工资要低一点，武汉是外包联盟了，都是外包公司，只有一个斗鱼比较出名。反射与注解：    反射：在运行时可以知道任意一个类的属性和方法；        具体的类是Class类的一个实例        Class的源码：构造方法私有        private  Class(ClassLoader loader) {            classLoader = loader;        }        Class clazz = Person.class;        Class clazz = p.getClass();        Clazz clazz = Class.forName("com.zjf.nicework,Persion");        Method[] methods = class1.getDeclaredMethods();//获取class对象的所有声明方法        Method[] allMethods = class1.getMethods();//获取class对象的所有public方法 包括父类的方法        Method method = class1.getMethod("info", String.class);//返回次Class对象对应类的、带指定形参列表的public方法        Method declaredMethod = class1.getDeclaredMethod("info", String.class);//返回次Class对象对应类的、带指定形参列表的方法        method.invoke(o, "str"); //对象和参数        Field[] allFields = class1.getDeclaredFields();//获取class对象的所有属性        Field[] publicFields = class1.getFields();//获取class对象的public属性        Field ageField = class1.getDeclaredField("age");//获取class指定属性        Field desField = class1.getField("des");//获取class指定的public属性        Object msg = field.get(o);        Constructor<?>[] allConstructors = class1.getDeclaredConstructors();//获取class对象的所有声明构造函数        Constructor<?>[] publicConstructors = class1.getConstructors();//获取class对象public构造函数        Constructor<?> constructor = class1.getDeclaredConstructor(String.class);//获取指定声明构造函数        Constructor publicConstructor = class1.getConstructor(String.class);//获取指定声明的public构造函数        注意：Class的newInstance方法，只能创建只包含无参数的构造函数的类，如果某类只有带参数的构造函数，那么就要使用另外一种方式：                fromClass.getDeclaredConstructor(String.class).newInstance("tengj");        例如类A有如下一个构造函数：        public A(String a, int b) {            // code body        }        那么就可以通过：        Constructor constructor = a.getDeclaredConstructor(String.class, int.class);        来获取这个构造函数。        //注解            @Target(ElementType.FIELD)            @Retention(RetentionPolicy.RUNTIME)            public @interface TestAnotation {                public int id() default -1;                public String name() default "";            }            isAnnotationPresent（A.isAnnotationPresent(B.class)；意思就是：注释B是否在此A上。如果在则返回true；不在则返回false。）            getAnnotation 获取注解加固 省电 省流量 性能优化 数据结构与算法耗电：硬件耗电（cpu,gpu,gps,wifi,屏幕，3G/4G蜂窝信号）    不能一直点亮屏幕（根据系统的休眠，熄屏 ），除非看视频    频繁的发送接收数据（蜂窝耗电，唤醒硬件和发送接收数据三个峰值，唤醒后存活一段时间，减少唤醒硬件耗电）Bind机制：    用户空间/内核空间    用户空间与内核空间 交互 通过系统调用，主要通过函数        copy_from_user()        copy_to_user()    内存映射：material design：原材料设计    层次感/Z轴/自然光，垂直光    colorPrimary：主色，    colorPrimaryDark：主色--深色，一般可以用于状态栏颜色、底部导航栏    colorAccent：（代表各个控件的基调颜色--CheckBox、RadioButton、ProgressBar等等）    可以考虑用兼容包里面的view，不然低版本效果就会不同 Android.supportt.v7.vidget.(listPopwindow,popMenu, )面试没答好的题：    组件化 flatmap 做过那秀优化 ANR屏幕适配：    布局适配（使用相对布局）    组件适配（wrap_content match_parent weigth）    使用限定符（最小宽度限定符）平板/电视（>7）双面板布局：resource/layout_sw600dp/main_activoty.xml    自适应图片（.9）    根据屏幕配置加载不同的用户界面流程    屏幕密度适配：        使用密度无关像素dp.sp/百分比适配        图片（提供备用图片）  xxdpi吗的还要考虑iOS所以用xdpi并行和并发：进程和线程    并行是同时使用，并发是一个个的时间片。    进程是操作系统进行资源分配的最小单位，线程是CPU调度和分配的基本单位。    单CPU无法被多个进程并行使用，只能进行并发，多CPU可以多个进程并行。    单CPU多核可以线程并行    http与https:    https优势：(数字签名技术)    内容加密：采用混合加密技术，中间者无法直接查看明文内容    验证身份：通过证书认证客户端访问的是自己的服务器    保护数据完整性：防止传输的内容被中间人冒充或者篡改        非对称加密过程需要用到公钥进行加密，那么公钥从何而来？其实公钥就被包含在数字证书中，数字证书通常来说是由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。数字证书被放到服务端，具有服务器身份验证和数据传输加密功能。        成本考虑：	SSL证书需要购买申请，功能越强大的证书费用越高	SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。	根据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电。	HTTPS连接缓存不如HTTP高效，流量成本高。	HTTPS连接服务器端资源占用高很多，支持访客多的网站需要投入更大的成本。	HTTPS协议握手阶段比较费时，对网站的响应速度有影响，影响用户体验。比较好的方式是采用分而治之，类似12306网站的主页使用HTTP协议，有关于用户信息等方面使用HTTPS。MD5:消息摘要，验证文件的完整性和正确性，主要正对的是文件Base64：比如图片文件，附件是二进制文件。电子邮件的协议不能支持到，使用base64进行编码，传输，在客户端再去解码得到原始文件。还有就是进行简单的加解密。gradle配置变动的时候，需要同步gradle文件，才能通过编译用代码添加子View	for (int i = 0; i < count; i++) {            ImageView iv = new ImageView(context);            iv.setImageResource(R.mipmap.ic_launcher);            DisplayMetrics displayMetrics = new DisplayMetrics();            context.getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);            float density = displayMetrics.density;            LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams((int)(25*density),(int)(25*density));            lp.leftMargin = 8;            holder.llHotXing.addView(iv,lp);        }			git 再次学习：git initgit add （添加到暂存区）git commit -m "" （保存快照，把暂存区的文件提交到当前分支）工作区与暂存区需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。git log --pretty=oneline （提交历史）git reflog 记录没一次的吗命令 （命令历史）git reset --hard HEAD^ 回退上一个版本git reset --hard commit_idgit statu （工作去状态）git checkout -- readme.txt （丢掉工作区的修改）	命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：       一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；       一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。        总之，就是让这个文件回到最近一次git commit或git add时的状态。	git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区：(撤销 add 命令，工作去不变)删除文件1，工作区删除2，git rm test.txt3.git commit -m ""错删git checkout -- test.txt （git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。）远程仓库：git remote add origin git@github.com:michaelliao/learngit.git （关联远程仓库）	添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。git push -u origin master 把本地仓库所有内容推送到远程仓库	由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。git push origin master假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。git clone git@github.com:michaelliao/gitskills.git	要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。        Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。美此提交，git都把它们串成一条时间线这条时间线就是一条分支git checkout -b dev 创建并切换分支	相当于git branch dev （创建分支）	      git checkout dev （切换分支）git branch 查看分支 git merge dev 合并dev分支到当前分支（成功则完成合并）git add readme.txt （当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。）用git log --graph命令可以看到分支合并图。git branch -a  查看所有分支git branch -d dev  删除本地分支git push origin --delete dev  删除远程分支git remote 查看远程仓库信息git remote -v 查看更详细信息： 	git remote -v	origin  git@github.com:michaelliao/learngit.git (fetch)	origin  git@github.com:michaelliao/learngit.git (push)	上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。	并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？master分支是主分支，因此要时刻与远程同步；dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！多人协作的工作模式通常是这样：首先，可以试图用git push origin <branch-name>推送自己的修改；如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；如果合并有冲突，则解决冲突，并在本地提交；没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to <branch-name> origin/<branch-name>。这就是多人协作的工作模式，一旦熟悉了，就非常简单。清空git缓存git rm -r --cached .git add .git commit -m 'update .gitignore'LayoutParams:ViewGroup的静态内部类tip：本地分支切换前，先把当前分支的修改先提交本地仓库layoutparams的使用：	for (int i = 0; i < startTotalCount; i++) {	    ImageView iv = new ImageView(context);	    if (i < count) {	        iv.setImageResource(R.mipmap.popular_hot_active);	    } else {	        iv.setImageResource(R.mipmap.popular_hot_inactive);	    }	    DisplayMetrics displayMetrics = new DisplayMetrics();	    context.getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);	    float density = displayMetrics.density;	    LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams((int) (10 * density), (int) (9 * density));	    lp.leftMargin = 8;	    holder.llHotXing.addView(iv, lp);	}	TextView textView = new TextView(context);	ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 200);	layoutParams.width=100;	layoutParams.height=200;	textView.setLayoutParams(layoutParams);	//设置权重比例	layoutParams1.weight=1;	//设置上部间距	layoutParams1.topMargin=5;	//设置右边间距	layoutParams1.setMarginEnd(20);	//设置四周间距	layoutParams1.setMargins(3,3,3,3);ProtocolBuffer:syntax = "proto2";		 版本号package tutorial;                #package是为了防止命名冲突（naming conflicts）message Person {                 #定义message  required string name = 1;      #数字1是唯一的标签（unique tag）。  required int32 id = 2;	 required必选字段  optional string email = 3;     optional可选字段 要么给定默认值 要么 数值类型为零，字符串为空字符串，bools为fasle  enum PhoneType {    MOBILE = 0;    HOME = 1;    WORK = 2;  }  message PhoneNumber {    required string number = 1;    optional PhoneType type = 2 [default = HOME];    #默认值是HOME  }  repeated PhoneNumber phones = 4;}message AddressBook {  repeated Person people = 1;   repeated可重复的}V1签名是对jar包的签名 V2签名是对整个apk的签名jsh互调：addJavascriptInterface（类的实例，别名）禁止Google的数据备份功能：tools:replace="android:allowBackup"        		android:allowBackup="false"cmd d: 进入盘 再cdMVP：    activity fragment 是view层，响应用户输入和处理生命周期。    Activity就能瘦身许多了，基本上只有FindView、SetListener以及Init的代码。其他的就是对Presenter的调用，还有对View接口的实现。    MVP把Activity中的UI逻辑抽象成View接口，把业务逻辑抽象成Presenter接口，Model类还是原来的Model。    Model和View之间的桥梁，为了让结构变得更加简单，View并不能直接对Model进行操作    解决内存泄漏可以说一下（异步任务保留着对activity的引用）自定义view：    自定义view第一个构造方法是new 用的，第二个构造方法是xml用的    我的手机  19:53:02    必须支持wrap_content属性，手动支持padding属性    我的手机  19:53:09    如果不手动设置支持wrap_content属性，那么wrap_content属性是不会生效（显示效果同match_parent）    我的手机  19:53:17    padding属性：用于设置控件内容相对控件边缘的边距；    区别与margin属性（同样称为：边距）：控件边缘相对父控件的边距（父控件控制）    我的手机  19:53:24    如果不手动设置支持padding属性，那么padding属性在自定义View中是不会生效的。    // 仅看复写的onDraw（）    @Override        protected void onDraw(Canvas canvas) {            super.onDraw(canvas);            // 获取传入的padding值            final int paddingLeft = getPaddingLeft();            final int paddingRight = getPaddingRight();            final int paddingTop = getPaddingTop();            final int paddingBottom = getPaddingBottom();            // 获取绘制内容的高度和宽度（考虑了四个方向的padding值）            int width = getWidth() - paddingLeft - paddingRight ;            int height = getHeight() - paddingTop - paddingBottom ;            // 设置圆的半径 = 宽,高最小值的2分之1            int r = Math.min(width, height)/2;            // 画出圆(蓝色)            // 圆心 = 控件的中央,半径 = 宽,高最小值的2分之1            canvas.drawCircle(paddingLeft+width/2,paddingTop+height/2,r,mPaint1);        }解决：wrap_content属性不起作用（与match_parent相同作用）原因：public static int getDefaultSize(int size, int measureSpec) {//参数说明：// 第一个参数size：提供的默认大小// 第二个参数：宽/高的测量规格（含模式 & 测量大小）    //设置默认大小    int result = size;    //获取宽/高测量规格的模式 & 测量大小    int specMode = MeasureSpec.getMode(measureSpec);    int specSize = MeasureSpec.getSize(measureSpec);    switch (specMode) {        // 模式为UNSPECIFIED时，使用提供的默认大小        // 即第一个参数：size        case MeasureSpec.UNSPECIFIED:            result = size;            break;        // 模式为AT_MOST,EXACTLY时，使用View测量后的宽/高值        // 即measureSpec中的specSize        case MeasureSpec.AT_MOST:        case MeasureSpec.EXACTLY:            result = specSize;            break;    } //返回View的宽/高值    return result;}解决方法：@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {    super.onMeasure(widthMeasureSpec, heightMeasureSpec);    // 获取宽-测量规则的模式和大小    int widthMode = MeasureSpec.getMode(widthMeasureSpec);    int widthSize = MeasureSpec.getSize(widthMeasureSpec);    // 获取高-测量规则的模式和大小    int heightMode = MeasureSpec.getMode(heightMeasureSpec);    int heightSize = MeasureSpec.getSize(heightMeasureSpec);    // 设置wrap_content的默认宽 / 高值    // 默认宽/高的设定并无固定依据,根据需要灵活设置    // 类似TextView,ImageView等针对wrap_content均在onMeasure()对设置默认宽 / 高值有特殊处理,具体读者可以自行查看    int mWidth = 400;    int mHeight = 400;  // 当布局参数设置为wrap_content时，设置默认值    if (getLayoutParams().width == ViewGroup.LayoutParams.WRAP_CONTENT && getLayoutParams().height == ViewGroup.LayoutParams.WRAP_CONTENT) {        setMeasuredDimension(mWidth, mHeight);    // 宽 / 高任意一个布局参数为= wrap_content时，都设置默认值    } else if (getLayoutParams().width == ViewGroup.LayoutParams.WRAP_CONTENT) {        setMeasuredDimension(mWidth, heightSize);    } else if (getLayoutParams().height == ViewGroup.LayoutParams.WRAP_CONTENT) {        setMeasuredDimension(widthSize, mHeight);}轮播：取余沉浸状态拦startBarColorwebView优化1.有效增大App的运存，减少由webview引起的内存泄露对主进程内存的占用。2.避免WebView的Crash影响App主进程的运行。3.拥有对WebView独立进程操控权。关闭硬件加速设置缓存图片处理：BitmapFactory.Options options = new BitmapFactory.Options();BitmapFactory.Options类有一个参数inSampleSizemImageView.setImageBitmap(decodeSampledBitmapFromResource(getResources(), R.id.myimage, 100,100));service:https://cloud.tencent.com/developer/article/1341705onCreate()onBind()onStartCommand()  stopSelf() (在任务完成后)onDestroy()1.同时调用了startService()和bindService()方法。此时需要调用unbindService()和stopService()才能触发Service的onDestory()方法。2.只调用了bindService()，没有调用startSerview()方法。此时只需要调用unbindService()即可触发Service的onDestory()方法。3.只调用了startService()，没有调用bindService()方法。此时只需要调用stopService()即可触发Service的onDestory()方法。需要注意的是，在没有调用bindService()的情况下，调用unbindService()方法会报错。Intent intent = new Intent(MainActivity.this, ServiceA.class);intent.putExtra("name", strName);startService(intent);IntentService处理流程创建默认的一个worker线程处理传递给onStartCommand()的所有intent，不占据应用的主线程创建一个工作队列一次传递一个intent到你实现的onHandleIntent()方法，避免了多线程在所以启动请求被处理后自动关闭服务，不需要调用stopSelf()默认提供onBind()的实现，并返回null默认提供onStartCommand()的实现，实现发送intent到工作队列再到你的onHandleIntent()方法实现。onStartCommand()的返回值返回一个整型值，用来描述系统在杀掉服务后是否要继续启动服务，返回值有三种：ServiceConnection在onBond方法中返回IBind对象前台服务系统提供的方法就是必须有notification参数的Notification startForeground()override(300,300).mImageView.setImageBitmap(decodeSampledBitmapFromResource(getResources(), R.id.myimage, 100,100));